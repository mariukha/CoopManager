from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import Optional, Any
from datetime import datetime
from db import get_cursor, get_connection
import time

app = FastAPI()

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

VALID_TABLES = ["budynek", "mieszkanie", "czlonek", "pracownik", "naprawa", "uslugi", "oplata"]

def init_database():
    init_sql = """
    DECLARE
        v_count NUMBER;
    BEGIN
        SELECT COUNT(*) INTO v_count FROM user_tables WHERE table_name = 'UZYTKOWNICY';
        IF v_count > 0 THEN
            RETURN;
        END IF;
        
        EXECUTE IMMEDIATE 'CREATE TABLE UZYTKOWNICY (
            ID_UZYTKOWNIKA NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            LOGIN VARCHAR2(50) NOT NULL UNIQUE,
            HASLO VARCHAR2(100) NOT NULL
        )';
        
        EXECUTE IMMEDIATE 'CREATE TABLE BUDYNEK (
            ID_BUDYNKU NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            ADRES VARCHAR2(100) NOT NULL,
            LICZBA_PIETER NUMBER,
            LICZBA_MIESZKAN NUMBER,
            ROK_BUDOWY NUMBER
        )';
        
        EXECUTE IMMEDIATE 'CREATE TABLE MIESZKANIE (
            ID_MIESZKANIA NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            NUMER VARCHAR2(10),
            POWIERZCHNIA NUMBER(10,2),
            LICZBA_POKOI NUMBER,
            PIETRO NUMBER,
            ID_BUDYNKU NUMBER,
            CONSTRAINT FK_MIESZKANIE_BUDYNEK FOREIGN KEY (ID_BUDYNKU) REFERENCES BUDYNEK(ID_BUDYNKU)
        )';
        
        EXECUTE IMMEDIATE 'CREATE TABLE CZLONEK (
            ID_CZLONKA NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            IMIE VARCHAR2(50),
            NAZWISKO VARCHAR2(50),
            NUMER_TELEFONU VARCHAR2(20),
            ID_MIESZKANIA NUMBER,
            CONSTRAINT FK_CZLONEK_MIESZKANIE FOREIGN KEY (ID_MIESZKANIA) REFERENCES MIESZKANIE(ID_MIESZKANIA)
        )';
        
        EXECUTE IMMEDIATE 'CREATE TABLE PRACOWNIK (
            ID_PRACOWNIKA NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            IMIE VARCHAR2(50),
            NAZWISKO VARCHAR2(50),
            STANOWISKO VARCHAR2(50),
            TELEFON VARCHAR2(20)
        )';
        
        EXECUTE IMMEDIATE 'CREATE TABLE NAPRAWA (
            ID_NAPRAWY NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            OPIS VARCHAR2(255),
            STATUS VARCHAR2(50),
            DATA_ZGLOSZENIA DATE DEFAULT SYSDATE,
            ID_MIESZKANIA NUMBER,
            ID_PRACOWNIKA NUMBER,
            CONSTRAINT FK_NAPRAWA_MIESZKANIE FOREIGN KEY (ID_MIESZKANIA) REFERENCES MIESZKANIE(ID_MIESZKANIA),
            CONSTRAINT FK_NAPRAWA_PRACOWNIK FOREIGN KEY (ID_PRACOWNIKA) REFERENCES PRACOWNIK(ID_PRACOWNIKA)
        )';
        
        EXECUTE IMMEDIATE 'CREATE TABLE USLUGI (
            ID_USLUGI NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            NAZWA_USLUGI VARCHAR2(100),
            JEDNOSTKA_MIARY VARCHAR2(20),
            CENA_ZA_JEDNOSTKE NUMBER(10,2)
        )';
        
        EXECUTE IMMEDIATE 'CREATE TABLE OPLATA (
            ID_OPLATY NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            ID_MIESZKANIA NUMBER,
            ID_USLUGI NUMBER,
            ZUZYCIE NUMBER(10,2),
            KWOTA NUMBER(10,2),
            DATA_PLATNOSCI DATE,
            STATUS_OPLATY VARCHAR2(50),
            CONSTRAINT FK_OPLATA_MIESZKANIE FOREIGN KEY (ID_MIESZKANIA) REFERENCES MIESZKANIE(ID_MIESZKANIA),
            CONSTRAINT FK_OPLATA_USLUGI FOREIGN KEY (ID_USLUGI) REFERENCES USLUGI(ID_USLUGI)
        )';
        
        EXECUTE IMMEDIATE 'CREATE TABLE LOG_ZMIAN_CZLONKA (
            ID_LOGU NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            ID_CZLONKA NUMBER,
            OPERACJA VARCHAR2(20),
            DATA_OPERACJI DATE DEFAULT SYSDATE,
            UZYTKOWNIK VARCHAR2(50)
        )';
        
        EXECUTE IMMEDIATE 'INSERT INTO UZYTKOWNICY (LOGIN, HASLO) VALUES (''admin'', ''admin123'')';
        EXECUTE IMMEDIATE 'INSERT INTO BUDYNEK (ADRES, LICZBA_PIETER, LICZBA_MIESZKAN, ROK_BUDOWY) VALUES (''Kwiatowa 15'', 4, 20, 2005)';
        EXECUTE IMMEDIATE 'INSERT INTO BUDYNEK (ADRES, LICZBA_PIETER, LICZBA_MIESZKAN, ROK_BUDOWY) VALUES (''Sloneczna 8'', 5, 25, 2010)';
        EXECUTE IMMEDIATE 'INSERT INTO MIESZKANIE (NUMER, POWIERZCHNIA, LICZBA_POKOI, PIETRO, ID_BUDYNKU) VALUES (''1'', 50.5, 2, 1, 1)';
        EXECUTE IMMEDIATE 'INSERT INTO MIESZKANIE (NUMER, POWIERZCHNIA, LICZBA_POKOI, PIETRO, ID_BUDYNKU) VALUES (''2'', 65.0, 3, 2, 1)';
        EXECUTE IMMEDIATE 'INSERT INTO MIESZKANIE (NUMER, POWIERZCHNIA, LICZBA_POKOI, PIETRO, ID_BUDYNKU) VALUES (''3'', 45.0, 2, 1, 2)';
        EXECUTE IMMEDIATE 'INSERT INTO CZLONEK (IMIE, NAZWISKO, NUMER_TELEFONU, ID_MIESZKANIA) VALUES (''Jan'', ''Kowalski'', ''123456789'', 1)';
        EXECUTE IMMEDIATE 'INSERT INTO CZLONEK (IMIE, NAZWISKO, NUMER_TELEFONU, ID_MIESZKANIA) VALUES (''Anna'', ''Nowak'', ''987654321'', 2)';
        EXECUTE IMMEDIATE 'INSERT INTO PRACOWNIK (IMIE, NAZWISKO, STANOWISKO, TELEFON) VALUES (''Tomasz'', ''Maj'', ''Konserwator'', ''555111222'')';
        EXECUTE IMMEDIATE 'INSERT INTO USLUGI (NAZWA_USLUGI, JEDNOSTKA_MIARY, CENA_ZA_JEDNOSTKE) VALUES (''Woda'', ''m3'', 10.50)';
        EXECUTE IMMEDIATE 'INSERT INTO USLUGI (NAZWA_USLUGI, JEDNOSTKA_MIARY, CENA_ZA_JEDNOSTKE) VALUES (''Gaz'', ''m3'', 3.20)';
        EXECUTE IMMEDIATE 'INSERT INTO USLUGI (NAZWA_USLUGI, JEDNOSTKA_MIARY, CENA_ZA_JEDNOSTKE) VALUES (''Prad'', ''kWh'', 0.85)';
        EXECUTE IMMEDIATE 'INSERT INTO OPLATA (ID_MIESZKANIA, ID_USLUGI, ZUZYCIE, KWOTA, DATA_PLATNOSCI, STATUS_OPLATY) VALUES (1, 1, 15, 157.50, SYSDATE-30, ''Zaleglosc'')';
        EXECUTE IMMEDIATE 'INSERT INTO OPLATA (ID_MIESZKANIA, ID_USLUGI, ZUZYCIE, KWOTA, DATA_PLATNOSCI, STATUS_OPLATY) VALUES (2, 2, 10, 32.00, SYSDATE+14, ''Wystawiono'')';
        EXECUTE IMMEDIATE 'INSERT INTO NAPRAWA (OPIS, STATUS, ID_MIESZKANIA, ID_PRACOWNIKA) VALUES (''Cieknacy kran'', ''Zgloszona'', 1, 1)';
        
        COMMIT;
    END;
    """
    
    max_retries = 30
    for attempt in range(max_retries):
        try:
            conn = get_connection()
            cursor = conn.cursor()
            cursor.execute(init_sql)
            conn.commit()
            cursor.close()
            conn.close()
            print("‚úÖ Database initialized successfully!")
            return
        except Exception as e:
            if attempt < max_retries - 1:
                print(f"‚è≥ Waiting for database... attempt {attempt + 1}/{max_retries}")
                time.sleep(5)
            else:
                print(f"‚ùå Database initialization failed: {e}")

@app.on_event("startup")
async def startup_event():
    print("üöÄ Starting application...")
    init_database()

def translate_oracle_error(error_msg: str) -> str:
    error_msg = str(error_msg)
    
    if "ORA-00001" in error_msg:
        return "Rekord o takim identyfikatorze ju≈º istnieje."
    if "ORA-02291" in error_msg:
        return "Nie mo≈ºna dodaƒá rekordu - brak powiƒÖzanego rekordu w tabeli nadrzƒôdnej."
    if "ORA-02292" in error_msg:
        return "Nie mo≈ºna usunƒÖƒá - istniejƒÖ powiƒÖzane rekordy w innych tabelach."
    if "ORA-01400" in error_msg:
        return "Brak wymaganej warto≈õci w polu obowiƒÖzkowym."
    if "ORA-01407" in error_msg:
        return "Pole obowiƒÖzkowe nie mo≈ºe byƒá puste."
    if "ORA-01722" in error_msg:
        return "B≈Çƒôdny format liczby."
    if "ORA-01830" in error_msg or "ORA-01861" in error_msg:
        return "Nieprawid≈Çowy format daty."
    if "ORA-01438" in error_msg:
        return "Warto≈õƒá liczbowa przekracza dozwolony zakres."
    if "ORA-12899" in error_msg:
        return "Wprowadzony tekst jest za d≈Çugi."
    if "ORA-00942" in error_msg:
        return "Tabela nie istnieje w bazie danych."
    if "ORA-00904" in error_msg:
        return "Nieprawid≈Çowa nazwa kolumny."
    if "ORA-02449" in error_msg:
        return "Nie mo≈ºna usunƒÖƒá tabeli - istniejƒÖ klucze obce."
    if "constraint" in error_msg.lower():
        return "Operacja narusza regu≈Çy integralno≈õci danych."
    
    return f"B≈ÇƒÖd bazy danych: {error_msg[:200]}"

def serialize_row(row: tuple, columns: list) -> dict:
    result = {}
    for col_name, value in zip(columns, row):
        if isinstance(value, datetime):
            result[col_name] = value.strftime("%Y-%m-%d")
        else:
            result[col_name] = value
    return result

class LoginRequest(BaseModel):
    login: str
    haslo: str

class ResidentLoginRequest(BaseModel):
    imie: str
    nazwisko: str
    numer: str

class RecordData(BaseModel):
    data: dict[str, Any]

class ProcedureRequest(BaseModel):
    procent: Optional[float] = None
    id_mieszkania: Optional[int] = None
    id_uslugi: Optional[int] = None
    zuzycie: Optional[float] = None

@app.get("/health")
async def health_check():
    return {"status": "ok"}

@app.post("/login")
async def login(req: LoginRequest):
    try:
        with get_cursor() as (cursor, conn):
            cursor.execute(
                "SELECT id_uzytkownika, login FROM uzytkownicy WHERE login = :1 AND haslo = :2",
                [req.login, req.haslo]
            )
            row = cursor.fetchone()
            if row:
                return {"success": True, "user": {"id": row[0], "login": row[1]}}
            raise HTTPException(status_code=401, detail="Nieprawid≈Çowe dane logowania")
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=translate_oracle_error(str(e)))

@app.post("/login/resident")
async def login_resident(req: ResidentLoginRequest):
    try:
        with get_cursor() as (cursor, conn):
            cursor.execute("""
                SELECT c.id_czlonka, c.imie, c.nazwisko, m.id_mieszkania, m.numer
                FROM czlonek c
                JOIN mieszkanie m ON c.id_mieszkania = m.id_mieszkania
                WHERE LOWER(c.imie) = LOWER(:1)
                  AND LOWER(c.nazwisko) = LOWER(:2)
                  AND m.numer = :3
            """, [req.imie, req.nazwisko, req.numer])
            row = cursor.fetchone()
            if row:
                return {
                    "success": True,
                    "user": {
                        "id": row[0],
                        "imie": row[1],
                        "nazwisko": row[2],
                        "apt_id": row[3],
                        "apt_num": row[4]
                    }
                }
            raise HTTPException(status_code=401, detail="Nie znaleziono mieszka≈Ñca")
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=translate_oracle_error(str(e)))

@app.get("/data/{table}")
async def get_table_data(table: str):
    if table not in VALID_TABLES:
        raise HTTPException(status_code=400, detail="Nieprawid≈Çowa tabela")
    
    try:
        with get_cursor() as (cursor, conn):
            cursor.execute(f"SELECT * FROM {table}")
            columns = [col[0].lower() for col in cursor.description]
            rows = cursor.fetchall()
            return [serialize_row(row, columns) for row in rows]
    except Exception as e:
        raise HTTPException(status_code=500, detail=translate_oracle_error(str(e)))

def convert_date_value(key: str, value):
    if value is None or value == '':
        return None
    if 'data' in key.lower() and isinstance(value, str) and '-' in value:
        return datetime.strptime(value.split('T')[0], '%Y-%m-%d')
    return value

@app.post("/data/{table}")
async def insert_record(table: str, record: RecordData):
    if table not in VALID_TABLES:
        raise HTTPException(status_code=400, detail="Nieprawid≈Çowa tabela")
    
    try:
        with get_cursor() as (cursor, conn):
            data = {k: convert_date_value(k, v) for k, v in record.data.items()}
            data = {k: v for k, v in data.items() if v is not None or 'data' not in k.lower()}
            columns = list(data.keys())
            placeholders = [f":{i+1}" for i in range(len(columns))]
            values = list(data.values())
            
            sql = f"INSERT INTO {table} ({', '.join(columns)}) VALUES ({', '.join(placeholders)})"
            print(f"SQL: {sql}, VALUES: {values}")
            cursor.execute(sql, values)
            conn.commit()
            return {"success": True, "message": "Rekord dodany"}
    except Exception as e:
        print(f"INSERT ERROR: {e}")
        raise HTTPException(status_code=500, detail=translate_oracle_error(str(e)))

@app.put("/data/{table}/{id_field}/{id_value}")
async def update_record(table: str, id_field: str, id_value: str, record: RecordData):
    if table not in VALID_TABLES:
        raise HTTPException(status_code=400, detail="Nieprawid≈Çowa tabela")
    
    try:
        with get_cursor() as (cursor, conn):
            fk_fields = ['id_mieszkania', 'id_uslugi', 'id_pracownika', 'id_budynku']
            data = {k: convert_date_value(k, v) for k, v in record.data.items() if not k.startswith('id_') or k in fk_fields}
            data = {k: v for k, v in data.items() if v is not None or 'data' not in k.lower()}
            set_clause = ", ".join([f"{k} = :{i+1}" for i, k in enumerate(data.keys())])
            values = list(data.values()) + [id_value]
            
            sql = f"UPDATE {table} SET {set_clause} WHERE {id_field} = :{len(values)}"
            print(f"UPDATE SQL: {sql}, VALUES: {values}")
            cursor.execute(sql, values)
            conn.commit()
            return {"success": True, "message": "Rekord zaktualizowany"}
    except Exception as e:
        print(f"UPDATE ERROR: {e}")
        raise HTTPException(status_code=500, detail=translate_oracle_error(str(e)))

@app.delete("/data/{table}/{id_field}/{id_value}")
async def delete_record(table: str, id_field: str, id_value: str):
    if table not in VALID_TABLES:
        raise HTTPException(status_code=400, detail="Nieprawid≈Çowa tabela")
    
    try:
        with get_cursor() as (cursor, conn):
            cursor.execute(f"DELETE FROM {table} WHERE {id_field} = :1", [id_value])
            conn.commit()
            return {"success": True, "message": "Rekord usuniƒôty"}
    except Exception as e:
        raise HTTPException(status_code=500, detail=translate_oracle_error(str(e)))

@app.get("/system/audit-logs")
async def get_audit_logs():
    try:
        with get_cursor() as (cursor, conn):
            cursor.execute("""
                SELECT id_logu, id_czlonka, operacja, data_operacji, uzytkownik
                FROM log_zmian_czlonka
                ORDER BY data_operacji DESC
                FETCH FIRST 100 ROWS ONLY
            """)
            columns = [col[0].lower() for col in cursor.description]
            rows = cursor.fetchall()
            return [serialize_row(row, columns) for row in rows]
    except Exception as e:
        raise HTTPException(status_code=500, detail=translate_oracle_error(str(e)))

@app.post("/procedures/increase-fees")
async def call_increase_fees(req: ProcedureRequest):
    try:
        with get_cursor() as (cursor, conn):
            cursor.execute("BEGIN zwieksz_oplaty; END;")
            conn.commit()
            return {"success": True, "message": "Op≈Çaty zwiƒôkszone o 10%"}
    except Exception as e:
        raise HTTPException(status_code=500, detail=translate_oracle_error(str(e)))

@app.post("/procedures/add-fee")
async def call_add_fee(req: ProcedureRequest):
    try:
        with get_cursor() as (cursor, conn):
            cursor.execute("SELECT MIN(id_mieszkania) FROM mieszkanie")
            apt_id = cursor.fetchone()[0]
            
            if not apt_id:
                return {"success": False, "message": "Brak mieszkan w bazie"}
            
            cursor.execute("""
                INSERT INTO oplata (id_mieszkania, id_uslugi, zuzycie, kwota, data_platnosci, status_oplaty)
                VALUES (:1, NULL, 0, 100.00, SYSDATE + 14, 'Wystawiono')
            """, [apt_id])
            conn.commit()
            
            return {"success": True, "message": f"Dodano oplate 100 PLN dla mieszkania ID: {apt_id}"}
    except Exception as e:
        print(f"ADD-FEE ERROR: {e}")
        raise HTTPException(status_code=500, detail=translate_oracle_error(str(e)))

@app.get("/reports/summary")
async def get_summary_report():
    try:
        with get_cursor() as (cursor, conn):
            cursor.execute("""
                SELECT 
                    u.nazwa_uslugi,
                    u.jednostka_miary,
                    NVL(SUM(o.zuzycie), 0) as total_zuzycie,
                    NVL(SUM(o.kwota), 0) as total_kwota
                FROM uslugi u
                LEFT JOIN oplata o ON u.id_uslugi = o.id_uslugi
                GROUP BY u.id_uslugi, u.nazwa_uslugi, u.jednostka_miary
                ORDER BY total_kwota DESC
            """)
            
            services_summary = []
            total_revenue = 0
            
            for row in cursor.fetchall():
                services_summary.append({
                    "nazwa_uslugi": row[0],
                    "jednostka_miary": row[1] or "szt",
                    "total_zuzycie": float(row[2]) if row[2] else 0,
                    "total_kwota": float(row[3]) if row[3] else 0
                })
                total_revenue += float(row[3]) if row[3] else 0
            
            cursor.execute("SELECT COUNT(*) FROM czlonek")
            members_count = cursor.fetchone()[0]
            
            cursor.execute("""
                SELECT COUNT(*) FROM oplata 
                WHERE status_oplaty = 'Zaleglosc'
            """)
            arrears_count = cursor.fetchone()[0]
            
            cursor.execute("""
                SELECT 
                    b.adres,
                    m.numer as numer_mieszkania,
                    u.nazwa_uslugi,
                    o.kwota,
                    o.data_platnosci
                FROM oplata o
                JOIN mieszkanie m ON o.id_mieszkania = m.id_mieszkania
                JOIN budynek b ON m.id_budynku = b.id_budynku
                LEFT JOIN uslugi u ON o.id_uslugi = u.id_uslugi
                WHERE o.status_oplaty = 'Zaleglosc'
                ORDER BY o.kwota DESC
                FETCH FIRST 50 ROWS ONLY
            """)
            
            unpaid_details = []
            for row in cursor.fetchall():
                unpaid_details.append({
                    "adres": row[0],
                    "numer_mieszkania": row[1],
                    "nazwa_uslugi": row[2] or "Inne",
                    "kwota": float(row[3]) if row[3] else 0,
                    "data_platnosci": row[4].strftime("%Y-%m-%d") if row[4] else None
                })
            
            return {
                "services_summary": services_summary,
                "total_revenue": total_revenue,
                "members_count": members_count,
                "arrears_count": arrears_count,
                "unpaid_details": unpaid_details
            }
    except Exception as e:
        print(f"REPORT ERROR: {e}")
        raise HTTPException(status_code=500, detail=translate_oracle_error(str(e)))

@app.get("/resident/my-data/{apt_id}")
async def get_resident_data(apt_id: int):
    try:
        with get_cursor() as (cursor, conn):
            cursor.execute("""
                SELECT id_oplaty, id_mieszkania, id_uslugi, kwota, data_platnosci, status_oplaty, zuzycie
                FROM oplata WHERE id_mieszkania = :1
                ORDER BY data_platnosci DESC
            """, [apt_id])
            cols_o = [col[0].lower() for col in cursor.description]
            oplaty = [serialize_row(row, cols_o) for row in cursor.fetchall()]
            
            cursor.execute("""
                SELECT id_naprawy, id_mieszkania, id_pracownika, opis, data_zgloszenia, status
                FROM naprawa WHERE id_mieszkania = :1
                ORDER BY data_zgloszenia DESC
            """, [apt_id])
            cols_n = [col[0].lower() for col in cursor.description]
            naprawy = [serialize_row(row, cols_n) for row in cursor.fetchall()]
            
            return {"oplaty": oplaty, "naprawy": naprawy}
    except Exception as e:
        raise HTTPException(status_code=500, detail=translate_oracle_error(str(e)))

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
