Politechnika Świętokrzyska
Wydział Elektrotechniki Automatyki i Informatyki
Bazy Danych - Laboratorium
Numer grupy: 2ID13A
Zespół laboratoryjny: Maksym Mariukha, Daniil Reznik, Artem Labunskyi
Wyniki prac laboratoryjnych z instrukcji 11
Data wykonania ćwiczenia: 17.12.2025

Przebieg laboratorium

--Zadanie 13. Rozpocznij zapisywanie wyników do pliku wyniki_lab11.txt  
SPOOL wyniki_lab11.txt

--Zadanie 14. Utworzyć funkcję dodawania danych do jednej z tabel z twojej bazy danych używającą sekwencji. Sprawdź poprawność działania funkcji.
CREATE SEQUENCE spotkanie_seq
    START WITH 1000
    INCREMENT BY 1;

CREATE OR REPLACE FUNCTION dodaj_spotkanie (
    p_temat   VARCHAR2,
    p_miejsce VARCHAR2,
    p_data    DATE
) RETURN NUMBER IS
    v_id NUMBER;
BEGIN
    v_id := spotkanie_seq.NEXTVAL;

    INSERT INTO spotkanie_mieszkancow (id_spotkania, temat, miejsce, data)
    VALUES (v_id, p_temat, p_miejsce, p_data);

    RETURN v_id;
END;
/

DECLARE
    v_id NUMBER;
BEGIN
    v_id := dodaj_spotkanie(
        'Planowanie remontu dachu',
        'Sala konferencyjna',
        SYSDATE + 7
    );
    DBMS_OUTPUT.PUT_LINE('Dodano spotkanie o ID: ' || v_id);
END;
/

--Zadanie 15. Utworzyć funkcję aktualizującą dane w jednej z tabeli ze swojej bazy danych. Sprawdź poprawność działania funkcji.
CREATE OR REPLACE FUNCTION aktualizuj_stan_konta (
    p_id_konta   NUMBER,
    p_nowa_kwota NUMBER
) RETURN NUMBER IS
BEGIN
    UPDATE konto_bankowe
    SET stan = p_nowa_kwota
    WHERE id_konta = p_id_konta;

    IF SQL%ROWCOUNT = 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Nie znaleziono konta');
    END IF;

    RETURN SQL%ROWCOUNT;
END;
/

DECLARE
    v_updated NUMBER;
BEGIN
    v_updated := aktualizuj_stan_konta(10, 2000.50);
    DBMS_OUTPUT.PUT_LINE('Liczba zaktualizowanych kont: ' || v_updated);
END;
/

--Zadanie 16. Utworzyć funkcję wyświetlającą dane z jednej z tabel z twojej bazy danych używającą CURSOR. Sprawdź poprawność działania funkcji.
CREATE OR REPLACE TYPE t_czlonek_obj AS OBJECT (
    id       NUMBER,
    imie     VARCHAR2(30),
    nazwisko VARCHAR2(30)
);
/

CREATE OR REPLACE TYPE t_czlonek_tab AS TABLE OF t_czlonek_obj;
/

CREATE OR REPLACE FUNCTION pobierz_czlonkow_mieszkania (
    p_id_mieszkania NUMBER
) RETURN t_czlonek_tab IS
    v_wynik t_czlonek_tab := t_czlonek_tab();
    CURSOR c_czlonkowie IS
        SELECT id_czlonka, imie, nazwisko
        FROM czlonek
        WHERE id_mieszkania = p_id_mieszkania;
BEGIN
    FOR r IN c_czlonkowie LOOP
        v_wynik.EXTEND;
        v_wynik(v_wynik.LAST) :=
            t_czlonek_obj(r.id_czlonka, r.imie, r.nazwisko);
    END LOOP;

    RETURN v_wynik;
END;
/

DECLARE
    v_lista t_czlonek_tab;
BEGIN
    v_lista := pobierz_czlonkow_mieszkania(407);

    IF v_lista.COUNT = 0 THEN
        DBMS_OUTPUT.PUT_LINE('Brak czlonkow dla mieszkania');
    ELSE
        FOR i IN v_lista.FIRST .. v_lista.LAST LOOP
            DBMS_OUTPUT.PUT_LINE(
                'Czlonek: ' || v_lista(i).imie || ' ' || v_lista(i).nazwisko
            );
        END LOOP;
    END IF;
END;
/

--Zadanie 17. Utwórz procedurę korzystającą z danych z twojej bazy danych używającą CURSOR. Sprawdź poprawność działania procedury.
CREATE OR REPLACE PROCEDURE wyswietl_naprawy_status (
    p_status VARCHAR2
) IS
    CURSOR c_naprawy IS
        SELECT id_naprawy, id_pracownika, id_mieszkania
        FROM naprawa
        WHERE status = p_status;

    v_count NUMBER := 0;
BEGIN
    DBMS_OUTPUT.PUT_LINE('Lista napraw o statusie: ' || p_status);

    FOR r IN c_naprawy LOOP
        v_count := v_count + 1;
        DBMS_OUTPUT.PUT_LINE(
            'Naprawa ID: ' || r.id_naprawy ||
            ' | Pracownik: ' || r.id_pracownika ||
            ' | Mieszkanie: ' || r.id_mieszkania
        );
    END LOOP;

    IF v_count = 0 THEN
        DBMS_OUTPUT.PUT_LINE('Brak napraw o podanym statusie');
    END IF;
END;
/

BEGIN
    wyswietl_naprawy_status('Oczekuje');
END;
/

--Zadanie 18. Utwórz procedurę usuwającą dane z jednej z tabel z twojej bazy danych. Sprawdź poprawność działania procedury.
CREATE OR REPLACE PROCEDURE usun_usluge_czlonka (
    p_id_uslugi NUMBER
) IS
BEGIN
    DELETE FROM uslugi
    WHERE id_uslugi = p_id_uslugi;

    IF SQL%ROWCOUNT > 0 THEN
        DBMS_OUTPUT.PUT_LINE(
            'Usluga o ID ' || p_id_uslugi || ' zostala usunieta.'
        );
    ELSE
        DBMS_OUTPUT.PUT_LINE(
            'Nie znaleziono uslugi o ID ' || p_id_uslugi
        );
    END IF;

    COMMIT;
END;
/

BEGIN
    usun_usluge_czlonka(3);
END;
/

--Zadanie 19. Zakończ zapis wyników do pliku.
SPOOL OFF;

Zawartość pliku wyniki_lab11.txt:

Sequence created.

PL/SQL procedure successfully completed.
Dodano spotkanie o ID: 1000
PL/SQL procedure successfully completed.

PL/SQL procedure successfully completed.
Liczba zaktualizowanych kont: 1
PL/SQL procedure successfully completed.

PL/SQL procedure successfully completed.
Czlonek: Maksym Mariukha
PL/SQL procedure successfully completed.

PL/SQL procedure successfully completed.
Lista napraw o statusie: Oczekuje
Naprawa ID: 1 | Pracownik: 50001 | Mieszkanie: 407
PL/SQL procedure successfully completed.

PL/SQL procedure successfully completed.
Usluga o ID 3 zostala usunieta.
PL/SQL procedure successfully completed.

Wniosek. Podczas laboratorium zrealizowaliśmy wszystkie zadania, co pozwoliło na praktyczne przećwiczenie proceduralnego rozszerzenia języka zapytań PL/SQL. Przetestowaliśmy tworzenie oraz działanie funkcji i procedur, które pozwalają na enkapsulację logiki biznesowej i automatyzację operacji na danych, takich jak wstawianie rekordów z użyciem sekwencji, aktualizacja informacji czy usuwanie danych. Zweryfikowaliśmy także wykorzystanie kursorów do kontrolowanego i sekwencyjnego przetwarzania wielu wierszy danych oraz tworzenie złożonych typów danych, w tym definicji obiektów i kolekcji (tablic zagnieżdżonych). Cały proces, wraz z wynikami wszystkich wykonanych bloków kodu i testów, został pomyślnie zapisany w pliku wyniki_lab11.txt. Laboratorium potwierdziło istotność wykorzystania logiki proceduralnej w celu zwiększenia efektywności zarządzania bazą danych oraz możliwości tworzenia bardziej strukturalnych i wydajnych aplikacji bazodanowych.