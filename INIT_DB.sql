CREATE TABLE budynek (
    id_budynku NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    adres VARCHAR2(200) NOT NULL,
    liczba_pieter NUMBER NOT NULL,
    rok_budowy NUMBER(4),
    liczba_mieszkan NUMBER
);

CREATE TABLE mieszkanie (
    id_mieszkania NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_budynku NUMBER NOT NULL,
    numer VARCHAR2(20) NOT NULL,
    metraz NUMBER(10,2),
    liczba_pokoi NUMBER,
    CONSTRAINT fk_mieszkanie_budynek FOREIGN KEY (id_budynku) REFERENCES budynek(id_budynku)
);

CREATE TABLE czlonek (
    id_czlonka NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_mieszkania NUMBER NOT NULL,
    imie VARCHAR2(100) NOT NULL,
    nazwisko VARCHAR2(100) NOT NULL,
    pesel VARCHAR2(11),
    telefon VARCHAR2(20),
    email VARCHAR2(100),
    data_przystapienia DATE DEFAULT SYSDATE,
    CONSTRAINT fk_czlonek_mieszkanie FOREIGN KEY (id_mieszkania) REFERENCES mieszkanie(id_mieszkania)
);

CREATE TABLE pracownik (
    id_pracownika NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    imie VARCHAR2(100) NOT NULL,
    nazwisko VARCHAR2(100) NOT NULL,
    stanowisko VARCHAR2(100),
    telefon VARCHAR2(20),
    email VARCHAR2(100),
    data_zatrudnienia DATE DEFAULT SYSDATE
);

CREATE TABLE uslugi (
    id_uslugi NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    nazwa_uslugi VARCHAR2(200) NOT NULL,
    cena_za_jednostke NUMBER(10,2) NOT NULL,
    jednostka_miary VARCHAR2(50)
);

CREATE TABLE naprawa (
    id_naprawy NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_mieszkania NUMBER NOT NULL,
    id_pracownika NUMBER,
    opis VARCHAR2(500),
    data_zgloszenia DATE DEFAULT SYSDATE,
    data_wykonania DATE,
    status VARCHAR2(50) DEFAULT 'zgloszona',
    CONSTRAINT fk_naprawa_mieszkanie FOREIGN KEY (id_mieszkania) REFERENCES mieszkanie(id_mieszkania),
    CONSTRAINT fk_naprawa_pracownik FOREIGN KEY (id_pracownika) REFERENCES pracownik(id_pracownika)
);

CREATE TABLE oplata (
    id_oplaty NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_mieszkania NUMBER NOT NULL,
    id_uslugi NUMBER NOT NULL,
    kwota NUMBER(10,2) NOT NULL,
    data_naliczenia DATE DEFAULT SYSDATE,
    status_oplaty VARCHAR2(50) DEFAULT 'nieoplacone',
    zuzycie NUMBER(10,3),
    CONSTRAINT fk_oplata_mieszkanie FOREIGN KEY (id_mieszkania) REFERENCES mieszkanie(id_mieszkania),
    CONSTRAINT fk_oplata_uslugi FOREIGN KEY (id_uslugi) REFERENCES uslugi(id_uslugi)
);

CREATE TABLE uzytkownicy (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    login VARCHAR2(100) NOT NULL UNIQUE,
    haslo VARCHAR2(255) NOT NULL
);

CREATE TABLE log_zmian_czlonka (
    id_logu NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_czlonka NUMBER,
    operacja VARCHAR2(50),
    stare_dane VARCHAR2(1000),
    nowe_dane VARCHAR2(1000),
    data_zmiany TIMESTAMP DEFAULT SYSTIMESTAMP
);

-- Tabela spotkań mieszkańców (Lab 7)
CREATE TABLE spotkanie_mieszkancow (
    id_spotkania NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    temat VARCHAR2(200) NOT NULL,
    miejsce VARCHAR2(100),
    data_spotkania DATE DEFAULT SYSDATE
);

-- Tabela umów (Lab 7)
CREATE TABLE umowa (
    id_umowy NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_mieszkania NUMBER NOT NULL,
    id_czlonka NUMBER NOT NULL,
    data_zawarcia DATE DEFAULT SYSDATE,
    data_wygasniecia DATE,
    typ_umowy VARCHAR2(50) DEFAULT 'najem',
    CONSTRAINT fk_umowa_mieszkanie FOREIGN KEY (id_mieszkania) REFERENCES mieszkanie(id_mieszkania),
    CONSTRAINT fk_umowa_czlonek FOREIGN KEY (id_czlonka) REFERENCES czlonek(id_czlonka)
);

-- Tabela kont bankowych (Lab 7)
CREATE TABLE konto_bankowe (
    id_konta NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_czlonka NUMBER NOT NULL,
    numer_konta VARCHAR2(30) NOT NULL,
    saldo NUMBER(12,2) DEFAULT 0,
    CONSTRAINT fk_konto_czlonek FOREIGN KEY (id_czlonka) REFERENCES czlonek(id_czlonka)
);

-- ============================================
-- PROCEDURY I FUNKCJE (Lab 11, 12)
-- ============================================

CREATE OR REPLACE PROCEDURE zwieksz_oplaty(p_procent IN NUMBER DEFAULT 10) AS
BEGIN
    UPDATE uslugi SET cena_za_jednostke = cena_za_jednostke * (1 + p_procent / 100);
    COMMIT;
END;
/

CREATE OR REPLACE FUNCTION dodaj_oplate_fn(
    p_id_mieszkania IN NUMBER,
    p_id_uslugi IN NUMBER,
    p_zuzycie IN NUMBER
) RETURN NUMBER AS
    v_cena NUMBER;
    v_kwota NUMBER;
BEGIN
    SELECT cena_za_jednostke INTO v_cena FROM uslugi WHERE id_uslugi = p_id_uslugi;
    v_kwota := v_cena * p_zuzycie;
    
    INSERT INTO oplata (id_mieszkania, id_uslugi, kwota, zuzycie)
    VALUES (p_id_mieszkania, p_id_uslugi, v_kwota, p_zuzycie);
    
    COMMIT;
    RETURN v_kwota;
END;
/

-- Funkcja z CURSOR (Lab 11)
CREATE OR REPLACE FUNCTION pobierz_czlonkow_budynku(p_id_budynku NUMBER) 
RETURN VARCHAR2 AS
    v_wynik VARCHAR2(4000) := '';
    CURSOR c_czlonkowie IS
        SELECT c.imie, c.nazwisko
        FROM czlonek c
        JOIN mieszkanie m ON c.id_mieszkania = m.id_mieszkania
        WHERE m.id_budynku = p_id_budynku;
BEGIN
    FOR r IN c_czlonkowie LOOP
        v_wynik := v_wynik || r.imie || ' ' || r.nazwisko || '; ';
    END LOOP;
    RETURN v_wynik;
END;
/

-- Funkcja dynamicznego SQL (Lab 13)
CREATE OR REPLACE FUNCTION policz_rekordy(p_nazwa_tabeli VARCHAR2) 
RETURN NUMBER AS
    v_sql VARCHAR2(200);
    v_wynik NUMBER;
BEGIN
    v_sql := 'SELECT COUNT(*) FROM ' || p_nazwa_tabeli;
    EXECUTE IMMEDIATE v_sql INTO v_wynik;
    RETURN v_wynik;
EXCEPTION
    WHEN OTHERS THEN
        RETURN -1;
END;
/

-- ============================================
-- PACKAGE (Lab 12)
-- ============================================

CREATE OR REPLACE PACKAGE coop_pkg IS
    PROCEDURE zwieksz_oplaty_pkg(p_procent NUMBER DEFAULT 10);
    FUNCTION policz_naprawy_pracownika(p_id_pracownika NUMBER) RETURN NUMBER;
    FUNCTION suma_oplat_mieszkania(p_id_mieszkania NUMBER) RETURN NUMBER;
END coop_pkg;
/

CREATE OR REPLACE PACKAGE BODY coop_pkg IS
    PROCEDURE zwieksz_oplaty_pkg(p_procent NUMBER DEFAULT 10) IS
    BEGIN
        UPDATE uslugi SET cena_za_jednostke = cena_za_jednostke * (1 + p_procent / 100);
        COMMIT;
    END zwieksz_oplaty_pkg;

    FUNCTION policz_naprawy_pracownika(p_id_pracownika NUMBER) RETURN NUMBER IS
        v_count NUMBER;
    BEGIN
        SELECT COUNT(*) INTO v_count FROM naprawa WHERE id_pracownika = p_id_pracownika;
        RETURN v_count;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RETURN 0;
    END policz_naprawy_pracownika;
    
    FUNCTION suma_oplat_mieszkania(p_id_mieszkania NUMBER) RETURN NUMBER IS
        v_suma NUMBER;
    BEGIN
        SELECT NVL(SUM(kwota), 0) INTO v_suma FROM oplata WHERE id_mieszkania = p_id_mieszkania;
        RETURN v_suma;
    END suma_oplat_mieszkania;
END coop_pkg;
/

-- ============================================
-- TRIGGERY (Lab 13)
-- ============================================

CREATE OR REPLACE TRIGGER trg_audit_czlonek
AFTER INSERT OR UPDATE OR DELETE ON czlonek
FOR EACH ROW
BEGIN
    IF INSERTING THEN
        INSERT INTO log_zmian_czlonka (id_czlonka, operacja, nowe_dane)
        VALUES (:NEW.id_czlonka, 'INSERT', :NEW.imie || ' ' || :NEW.nazwisko);
    ELSIF UPDATING THEN
        INSERT INTO log_zmian_czlonka (id_czlonka, operacja, stare_dane, nowe_dane)
        VALUES (:OLD.id_czlonka, 'UPDATE', :OLD.imie || ' ' || :OLD.nazwisko, :NEW.imie || ' ' || :NEW.nazwisko);
    ELSIF DELETING THEN
        INSERT INTO log_zmian_czlonka (id_czlonka, operacja, stare_dane)
        VALUES (:OLD.id_czlonka, 'DELETE', :OLD.imie || ' ' || :OLD.nazwisko);
    END IF;
END;
/

-- Trigger walidacji kwoty (Lab 13)
CREATE OR REPLACE TRIGGER trg_walidacja_oplaty
BEFORE INSERT OR UPDATE OF kwota ON oplata
FOR EACH ROW
BEGIN
    IF :NEW.kwota < 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Kwota oplaty nie moze byc ujemna');
    END IF;
END;
/

-- ============================================
-- WIDOKI (Lab 9)
-- ============================================

-- Widok prosty
CREATE OR REPLACE VIEW v_mieszkania_info AS
SELECT m.id_mieszkania, m.numer, m.metraz, m.liczba_pokoi, b.adres
FROM mieszkanie m
JOIN budynek b ON m.id_budynku = b.id_budynku;

-- Widok złożony z agregacją
CREATE OR REPLACE VIEW v_oplaty_summary AS
SELECT 
    m.id_mieszkania,
    m.numer,
    COUNT(o.id_oplaty) AS liczba_oplat,
    NVL(SUM(o.kwota), 0) AS suma_oplat,
    NVL(SUM(CASE WHEN o.status_oplaty = 'nieoplacone' THEN o.kwota ELSE 0 END), 0) AS zaleglosci
FROM mieszkanie m
LEFT JOIN oplata o ON m.id_mieszkania = o.id_mieszkania
GROUP BY m.id_mieszkania, m.numer;

-- Widok z CASE (Lab 9)
CREATE OR REPLACE VIEW v_naprawy_status AS
SELECT 
    n.id_naprawy,
    n.opis,
    n.status,
    CASE 
        WHEN n.status = 'zgloszona' THEN 'Oczekuje na realizacje'
        WHEN n.status = 'w trakcie' THEN 'W trakcie realizacji'
        WHEN n.status = 'wykonana' THEN 'Zakonczona'
        ELSE 'Nieznany status'
    END AS opis_statusu,
    p.imie || ' ' || p.nazwisko AS pracownik
FROM naprawa n
LEFT JOIN pracownik p ON n.id_pracownika = p.id_pracownika;

-- ============================================
-- WIDOKI Z ROZNYMI JOIN (Lab 10)
-- ============================================

-- RIGHT JOIN - wszystkie naprawy z pracownikami (Lab 10)
CREATE OR REPLACE VIEW v_pracownicy_naprawy AS
SELECT 
    p.id_pracownika,
    p.imie || ' ' || p.nazwisko AS pracownik,
    p.stanowisko,
    n.id_naprawy,
    n.status AS status_naprawy
FROM naprawa n
RIGHT JOIN pracownik p ON n.id_pracownika = p.id_pracownika;

-- FULL OUTER JOIN - oplaty z uslugami (Lab 10)
CREATE OR REPLACE VIEW v_oplaty_uslugi_full AS
SELECT 
    o.id_oplaty,
    o.kwota,
    o.status_oplaty,
    u.id_uslugi,
    u.nazwa_uslugi,
    u.cena_za_jednostke
FROM oplata o
FULL OUTER JOIN uslugi u ON o.id_uslugi = u.id_uslugi;

-- CROSS JOIN - kombinacje budynkow i uslug (Lab 10)
CREATE OR REPLACE VIEW v_budynki_uslugi_cross AS
SELECT 
    b.id_budynku,
    b.adres,
    u.id_uslugi,
    u.nazwa_uslugi
FROM budynek b
CROSS JOIN uslugi u;

-- SELF JOIN - pracownicy w tym samym budynku (Lab 10)
CREATE OR REPLACE VIEW v_pracownicy_koledzy AS
SELECT 
    p1.id_pracownika AS pracownik_id,
    p1.imie || ' ' || p1.nazwisko AS pracownik,
    p2.id_pracownika AS kolega_id,
    p2.imie || ' ' || p2.nazwisko AS kolega,
    p1.stanowisko
FROM pracownik p1
JOIN pracownik p2 ON p1.stanowisko = p2.stanowisko
WHERE p1.id_pracownika < p2.id_pracownika;

-- JOIN 3 tabel - czlonkowie z mieszkaniami i budynkami (Lab 10)
CREATE OR REPLACE VIEW v_czlonkowie_pelne_info AS
SELECT 
    c.id_czlonka,
    c.imie,
    c.nazwisko,
    c.telefon,
    m.numer AS numer_mieszkania,
    m.metraz,
    b.adres AS adres_budynku,
    b.liczba_pieter
FROM czlonek c
INNER JOIN mieszkanie m ON c.id_mieszkania = m.id_mieszkania
INNER JOIN budynek b ON m.id_budynku = b.id_budynku;

-- ============================================
-- SEQUENCE (Lab 11)
-- ============================================

CREATE SEQUENCE spotkanie_seq START WITH 1000 INCREMENT BY 1;
CREATE SEQUENCE naprawa_seq START WITH 1000 INCREMENT BY 1;

-- ============================================
-- PROCEDURY CRUD (Lab 11)
-- ============================================

-- Procedura INSERT dla czlonka (Lab 11)
CREATE OR REPLACE PROCEDURE dodaj_czlonka(
    p_id_mieszkania IN NUMBER,
    p_imie IN VARCHAR2,
    p_nazwisko IN VARCHAR2,
    p_pesel IN VARCHAR2 DEFAULT NULL,
    p_telefon IN VARCHAR2 DEFAULT NULL,
    p_email IN VARCHAR2 DEFAULT NULL,
    p_id_czlonka OUT NUMBER
) AS
BEGIN
    INSERT INTO czlonek (id_mieszkania, imie, nazwisko, pesel, telefon, email)
    VALUES (p_id_mieszkania, p_imie, p_nazwisko, p_pesel, p_telefon, p_email)
    RETURNING id_czlonka INTO p_id_czlonka;
    COMMIT;
EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        RAISE_APPLICATION_ERROR(-20002, 'Czlonek o takim identyfikatorze juz istnieje');
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-20003, 'Blad podczas dodawania czlonka: ' || SQLERRM);
END;
/

-- Procedura UPDATE dla czlonka (Lab 11)
CREATE OR REPLACE PROCEDURE aktualizuj_czlonka(
    p_id_czlonka IN NUMBER,
    p_imie IN VARCHAR2 DEFAULT NULL,
    p_nazwisko IN VARCHAR2 DEFAULT NULL,
    p_telefon IN VARCHAR2 DEFAULT NULL,
    p_email IN VARCHAR2 DEFAULT NULL,
    p_rows_updated OUT NUMBER
) AS
BEGIN
    UPDATE czlonek
    SET imie = NVL(p_imie, imie),
        nazwisko = NVL(p_nazwisko, nazwisko),
        telefon = NVL(p_telefon, telefon),
        email = NVL(p_email, email)
    WHERE id_czlonka = p_id_czlonka;
    
    p_rows_updated := SQL%ROWCOUNT;
    
    IF p_rows_updated = 0 THEN
        RAISE_APPLICATION_ERROR(-20004, 'Nie znaleziono czlonka o ID: ' || p_id_czlonka);
    END IF;
    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE;
END;
/

-- Procedura DELETE dla czlonka (Lab 11)
CREATE OR REPLACE PROCEDURE usun_czlonka(
    p_id_czlonka IN NUMBER,
    p_rows_deleted OUT NUMBER
) AS
BEGIN
    DELETE FROM czlonek WHERE id_czlonka = p_id_czlonka;
    p_rows_deleted := SQL%ROWCOUNT;
    
    IF p_rows_deleted = 0 THEN
        RAISE_APPLICATION_ERROR(-20005, 'Nie znaleziono czlonka o ID: ' || p_id_czlonka);
    END IF;
    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE;
END;
/

-- Procedura z CURSOR wyswietlajaca naprawy (Lab 11)
CREATE OR REPLACE PROCEDURE wyswietl_naprawy_wg_statusu(
    p_status IN VARCHAR2,
    p_result OUT SYS_REFCURSOR
) AS
BEGIN
    OPEN p_result FOR
        SELECT n.id_naprawy, n.opis, n.data_zgloszenia, n.data_wykonania,
               m.numer AS numer_mieszkania,
               p.imie || ' ' || p.nazwisko AS pracownik
        FROM naprawa n
        LEFT JOIN mieszkanie m ON n.id_mieszkania = m.id_mieszkania
        LEFT JOIN pracownik p ON n.id_pracownika = p.id_pracownika
        WHERE n.status = p_status
        ORDER BY n.data_zgloszenia DESC;
END;
/

-- Funkcja dodajaca spotkanie z SEQUENCE (Lab 11)
CREATE OR REPLACE FUNCTION dodaj_spotkanie(
    p_temat IN VARCHAR2,
    p_miejsce IN VARCHAR2,
    p_data IN DATE DEFAULT SYSDATE
) RETURN NUMBER AS
    v_id NUMBER;
BEGIN
    v_id := spotkanie_seq.NEXTVAL;
    INSERT INTO spotkanie_mieszkancow (id_spotkania, temat, miejsce, data_spotkania)
    VALUES (v_id, p_temat, p_miejsce, p_data);
    COMMIT;
    RETURN v_id;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RETURN -1;
END;
/

-- Funkcja aktualizujaca saldo konta (Lab 11)
CREATE OR REPLACE FUNCTION aktualizuj_saldo_konta(
    p_id_konta IN NUMBER,
    p_nowe_saldo IN NUMBER
) RETURN NUMBER AS
    v_rows NUMBER;
BEGIN
    UPDATE konto_bankowe
    SET saldo = p_nowe_saldo
    WHERE id_konta = p_id_konta;
    
    v_rows := SQL%ROWCOUNT;
    COMMIT;
    RETURN v_rows;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RETURN -1;
END;
/

-- ============================================
-- ROZSZERZONY PACKAGE (Lab 12)
-- ============================================

-- Dodanie do istniejacego package
CREATE OR REPLACE PACKAGE coop_crud_pkg IS
    -- CRUD procedures
    PROCEDURE insert_budynek(p_adres VARCHAR2, p_liczba_pieter NUMBER, p_rok_budowy NUMBER, p_id OUT NUMBER);
    PROCEDURE update_budynek(p_id NUMBER, p_adres VARCHAR2, p_liczba_pieter NUMBER);
    PROCEDURE delete_budynek(p_id NUMBER, p_deleted OUT NUMBER);
    
    -- Funkcje z obsluga wyjatkow (Lab 12)
    FUNCTION pobierz_nazwisko_czlonka(p_id NUMBER) RETURN VARCHAR2;
    FUNCTION pobierz_adres_budynku(p_id NUMBER) RETURN VARCHAR2;
    
    -- Statystyki
    FUNCTION statystyki_budynku(p_id_budynku NUMBER) RETURN VARCHAR2;
END coop_crud_pkg;
/

CREATE OR REPLACE PACKAGE BODY coop_crud_pkg IS
    
    PROCEDURE insert_budynek(p_adres VARCHAR2, p_liczba_pieter NUMBER, p_rok_budowy NUMBER, p_id OUT NUMBER) IS
    BEGIN
        INSERT INTO budynek (adres, liczba_pieter, rok_budowy)
        VALUES (p_adres, p_liczba_pieter, p_rok_budowy)
        RETURNING id_budynku INTO p_id;
        COMMIT;
    EXCEPTION
        WHEN DUP_VAL_ON_INDEX THEN
            p_id := -1;
            RAISE_APPLICATION_ERROR(-20010, 'Budynek o tym adresie juz istnieje');
    END insert_budynek;
    
    PROCEDURE update_budynek(p_id NUMBER, p_adres VARCHAR2, p_liczba_pieter NUMBER) IS
    BEGIN
        UPDATE budynek 
        SET adres = p_adres, liczba_pieter = p_liczba_pieter
        WHERE id_budynku = p_id;
        
        IF SQL%ROWCOUNT = 0 THEN
            RAISE_APPLICATION_ERROR(-20011, 'Nie znaleziono budynku o ID: ' || p_id);
        END IF;
        COMMIT;
    END update_budynek;
    
    PROCEDURE delete_budynek(p_id NUMBER, p_deleted OUT NUMBER) IS
    BEGIN
        DELETE FROM budynek WHERE id_budynku = p_id;
        p_deleted := SQL%ROWCOUNT;
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            p_deleted := 0;
            ROLLBACK;
    END delete_budynek;
    
    FUNCTION pobierz_nazwisko_czlonka(p_id NUMBER) RETURN VARCHAR2 IS
        v_nazwisko czlonek.nazwisko%TYPE;
    BEGIN
        SELECT nazwisko INTO v_nazwisko FROM czlonek WHERE id_czlonka = p_id;
        RETURN v_nazwisko;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RETURN 'Nie znaleziono';
        WHEN TOO_MANY_ROWS THEN
            RETURN 'Wiele wynikow';
    END pobierz_nazwisko_czlonka;
    
    FUNCTION pobierz_adres_budynku(p_id NUMBER) RETURN VARCHAR2 IS
        v_adres budynek.adres%TYPE;
    BEGIN
        SELECT adres INTO v_adres FROM budynek WHERE id_budynku = p_id;
        RETURN v_adres;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RETURN 'Nie znaleziono';
    END pobierz_adres_budynku;
    
    FUNCTION statystyki_budynku(p_id_budynku NUMBER) RETURN VARCHAR2 IS
        v_mieszkan NUMBER;
        v_czlonkow NUMBER;
        v_napraw NUMBER;
    BEGIN
        SELECT COUNT(*) INTO v_mieszkan FROM mieszkanie WHERE id_budynku = p_id_budynku;
        
        SELECT COUNT(*) INTO v_czlonkow 
        FROM czlonek c 
        JOIN mieszkanie m ON c.id_mieszkania = m.id_mieszkania 
        WHERE m.id_budynku = p_id_budynku;
        
        SELECT COUNT(*) INTO v_napraw 
        FROM naprawa n 
        JOIN mieszkanie m ON n.id_mieszkania = m.id_mieszkania 
        WHERE m.id_budynku = p_id_budynku;
        
        RETURN 'Mieszkan: ' || v_mieszkan || ', Czlonkow: ' || v_czlonkow || ', Napraw: ' || v_napraw;
    EXCEPTION
        WHEN OTHERS THEN
            RETURN 'Blad: ' || SQLERRM;
    END statystyki_budynku;
    
END coop_crud_pkg;
/

-- ============================================
-- DANE TESTOWE
-- ============================================

INSERT INTO uzytkownicy (login, haslo) VALUES ('admin', 'admin123');

INSERT INTO budynek (adres, liczba_pieter, rok_budowy, liczba_mieszkan) VALUES ('ul. Kwiatowa 15', 5, 2005, 20);
INSERT INTO budynek (adres, liczba_pieter, rok_budowy, liczba_mieszkan) VALUES ('ul. Sloneczna 8', 4, 2010, 16);
INSERT INTO budynek (adres, liczba_pieter, rok_budowy, liczba_mieszkan) VALUES ('ul. Parkowa 22', 6, 2015, 24);

INSERT INTO mieszkanie (id_budynku, numer, metraz, liczba_pokoi) VALUES (1, '1A', 45.5, 2);
INSERT INTO mieszkanie (id_budynku, numer, metraz, liczba_pokoi) VALUES (1, '2B', 65.0, 3);
INSERT INTO mieszkanie (id_budynku, numer, metraz, liczba_pokoi) VALUES (2, '3C', 55.0, 2);
INSERT INTO mieszkanie (id_budynku, numer, metraz, liczba_pokoi) VALUES (3, '4D', 80.0, 4);

INSERT INTO czlonek (id_mieszkania, imie, nazwisko, pesel, telefon, email) VALUES (1, 'Jan', 'Kowalski', '85010112345', '501123456', 'jan.kowalski@email.pl');
INSERT INTO czlonek (id_mieszkania, imie, nazwisko, pesel, telefon, email) VALUES (2, 'Anna', 'Nowak', '90020298765', '502234567', 'anna.nowak@email.pl');
INSERT INTO czlonek (id_mieszkania, imie, nazwisko, pesel, telefon, email) VALUES (3, 'Piotr', 'Wisniewski', '78030367890', '503345678', 'piotr.wisniewski@email.pl');
INSERT INTO czlonek (id_mieszkania, imie, nazwisko, pesel, telefon, email) VALUES (4, 'Maria', 'Dabrowska', '82040445678', '504456789', 'maria.dabrowska@email.pl');

INSERT INTO pracownik (imie, nazwisko, stanowisko, telefon, email) VALUES ('Tomasz', 'Maj', 'Konserwator', '600111222', 'tomasz.maj@spoldzielnia.pl');
INSERT INTO pracownik (imie, nazwisko, stanowisko, telefon, email) VALUES ('Ewa', 'Lewandowska', 'Administrator', '600222333', 'ewa.lewandowska@spoldzielnia.pl');

INSERT INTO uslugi (nazwa_uslugi, cena_za_jednostke, jednostka_miary) VALUES ('Woda zimna', 5.50, 'm3');
INSERT INTO uslugi (nazwa_uslugi, cena_za_jednostke, jednostka_miary) VALUES ('Woda ciepla', 12.80, 'm3');
INSERT INTO uslugi (nazwa_uslugi, cena_za_jednostke, jednostka_miary) VALUES ('Ogrzewanie', 4.20, 'm2');
INSERT INTO uslugi (nazwa_uslugi, cena_za_jednostke, jednostka_miary) VALUES ('Wywoz smieci', 25.00, 'szt');
INSERT INTO uslugi (nazwa_uslugi, cena_za_jednostke, jednostka_miary) VALUES ('Czynsz', 8.50, 'm2');

INSERT INTO oplata (id_mieszkania, id_uslugi, kwota, zuzycie, status_oplaty) VALUES (1, 1, 55.00, 10, 'oplacone');
INSERT INTO oplata (id_mieszkania, id_uslugi, kwota, zuzycie, status_oplaty) VALUES (1, 3, 191.10, 45.5, 'nieoplacone');
INSERT INTO oplata (id_mieszkania, id_uslugi, kwota, zuzycie, status_oplaty) VALUES (2, 1, 66.00, 12, 'oplacone');
INSERT INTO oplata (id_mieszkania, id_uslugi, kwota, zuzycie, status_oplaty) VALUES (2, 5, 552.50, 65, 'nieoplacone');
INSERT INTO oplata (id_mieszkania, id_uslugi, kwota, zuzycie, status_oplaty) VALUES (3, 2, 128.00, 10, 'oplacone');
INSERT INTO oplata (id_mieszkania, id_uslugi, kwota, zuzycie, status_oplaty) VALUES (4, 4, 25.00, 1, 'nieoplacone');

INSERT INTO naprawa (id_mieszkania, id_pracownika, opis, status) VALUES (1, 1, 'Naprawa cieknacego kranu w lazience', 'wykonana');
INSERT INTO naprawa (id_mieszkania, id_pracownika, opis, status) VALUES (2, 1, 'Wymiana zamka w drzwiach wejsciowych', 'w trakcie');
INSERT INTO naprawa (id_mieszkania, opis, status) VALUES (3, 'Awaria ogrzewania - brak cieplej wody', 'zgloszona');

-- Dane dla nowych tabel
INSERT INTO spotkanie_mieszkancow (temat, miejsce, data_spotkania) VALUES ('Zebranie roczne', 'Sala konferencyjna', SYSDATE - 30);
INSERT INTO spotkanie_mieszkancow (temat, miejsce, data_spotkania) VALUES ('Sprawy biezace', 'Portiernia', SYSDATE - 7);
INSERT INTO spotkanie_mieszkancow (temat, miejsce, data_spotkania) VALUES ('Plan remontow 2026', 'Sala konferencyjna', SYSDATE + 14);

INSERT INTO umowa (id_mieszkania, id_czlonka, data_zawarcia, data_wygasniecia, typ_umowy) VALUES (1, 1, DATE '2023-01-15', DATE '2026-01-15', 'najem');
INSERT INTO umowa (id_mieszkania, id_czlonka, data_zawarcia, data_wygasniecia, typ_umowy) VALUES (2, 2, DATE '2022-06-01', DATE '2025-06-01', 'wlasnosc');
INSERT INTO umowa (id_mieszkania, id_czlonka, data_zawarcia, data_wygasniecia, typ_umowy) VALUES (3, 3, DATE '2024-03-01', DATE '2027-03-01', 'najem');
INSERT INTO umowa (id_mieszkania, id_czlonka, data_zawarcia, data_wygasniecia, typ_umowy) VALUES (4, 4, DATE '2021-09-01', NULL, 'wlasnosc');

INSERT INTO konto_bankowe (id_czlonka, numer_konta, saldo) VALUES (1, 'PL61109010140000071219812874', 1500.00);
INSERT INTO konto_bankowe (id_czlonka, numer_konta, saldo) VALUES (2, 'PL49102028922276300500000000', 250.50);
INSERT INTO konto_bankowe (id_czlonka, numer_konta, saldo) VALUES (3, 'PL32105010251000009080000000', -120.00);
INSERT INTO konto_bankowe (id_czlonka, numer_konta, saldo) VALUES (4, 'PL83101010230000261395100000', 0.00);

COMMIT;
