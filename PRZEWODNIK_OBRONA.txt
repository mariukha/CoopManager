# PRZEWODNIK DO OBRONY PROJEKTU
# System Zarzadzania Spoldzielnia Mieszkaniowa
# LAB 7-13

================================================================================
## JAK KORZYSTAC Z TEGO DOKUMENTU
================================================================================

Wykladowca bedzie pytac: "Czy zaimplementowales [element]? Pokaz gdzie."

Dla kazdego elementu ponizej znajdziesz:
- CO TO JEST - krotki opis
- GDZIE POKAZAC - sciezka w aplikacji
- KOD SQL/PYTHON - fragment kodu do pokazania

================================================================================
## LAB 7: CREATE TABLE, PRIMARY KEY, FOREIGN KEY, INSERT, UPDATE, DELETE
================================================================================

### 7.1. CREATE TABLE z PRIMARY KEY
-----------------------------------------
CO TO JEST: Tworzenie tabel z kluczem glownym

GDZIE POKAZAC: 
- Plik: INIT_DB.sql (linie 1-100)
- Lub: Panel Admin -> dowolna tabela (np. Budynki)

KOD SQL:
```sql
CREATE TABLE budynek (
    id_budynku NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    adres VARCHAR2(200) NOT NULL,
    -- ...
);
```

### 7.2. FOREIGN KEY
-----------------------------------------
CO TO JEST: Klucze obce laczace tabele

GDZIE POKAZAC:
- Plik: INIT_DB.sql
- Aplikacja: Panel Admin -> Mieszkania (kolumna id_budynku)

KOD SQL:
```sql
CREATE TABLE mieszkanie (
    id_mieszkania NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_budynku NUMBER NOT NULL,
    CONSTRAINT fk_mieszkanie_budynek 
        FOREIGN KEY (id_budynku) REFERENCES budynek(id_budynku) ON DELETE CASCADE
);
```

### 7.3. INSERT (dodawanie rekordow)
-----------------------------------------
CO TO JEST: Wstawianie nowych rekordow

GDZIE POKAZAC:
- Aplikacja: Panel Admin -> Budynki -> przycisk "Dodaj rekord"
- Backend: main.py linia ~325 (endpoint POST /data/{table})

KOD PYTHON:
```python
@app.post("/data/{table}")
async def insert_record(table: str, record: dict):
    # INSERT INTO budynek (adres, ...) VALUES (:adres, ...)
```

### 7.4. UPDATE (aktualizacja rekordow)
-----------------------------------------
CO TO JEST: Modyfikacja istniejacych rekordow

GDZIE POKAZAC:
- Aplikacja: Panel Admin -> Budynki -> ikona olowka przy rekordzie
- Backend: main.py (endpoint PUT /data/{table}/{id})

### 7.5. DELETE (usuwanie rekordow)
-----------------------------------------
CO TO JEST: Usuwanie rekordow

GDZIE POKAZAC:
- Aplikacja: Panel Admin -> Budynki -> ikona kosza przy rekordzie
- Backend: main.py (endpoint DELETE /data/{table}/{id})

### 7.6. ALTER TABLE ADD
-----------------------------------------
CO TO JEST: Dodawanie nowych kolumn do istniejacych tabel

GDZIE POKAZAC:
- Plik: INIT_DB.sql (szukaj "ALTER TABLE")

KOD SQL:
```sql
ALTER TABLE naprawa ADD uwagi VARCHAR2(500);
ALTER TABLE naprawa ADD priorytet VARCHAR2(20) DEFAULT 'sredni';
ALTER TABLE budynek ADD typ_budynku VARCHAR2(50) DEFAULT 'blok';
```

================================================================================
## LAB 8: SELECT z WHERE, ORDER BY, GROUP BY, funkcje agregujace, CASE
================================================================================

### 8.1. SELECT z WHERE LIKE
-----------------------------------------
CO TO JEST: Wyszukiwanie tekstowe w bazie danych

GDZIE POKAZAC:
- Aplikacja: Panel Admin -> dowolna tabela -> pole "Szukaj..."
- Wpisz np. "Kowalski" i zobacz jak filtruje

KOD SQL (generowany dynamicznie):
```sql
SELECT * FROM czlonek 
WHERE UPPER(imie) LIKE UPPER('%Kowalski%') 
   OR UPPER(nazwisko) LIKE UPPER('%Kowalski%')
```

KOD PYTHON (backend/main.py linia ~260):
```python
@app.get("/data/{table}/search")
async def search_table_data(table: str, q: str = ""):
    like_clauses = " OR ".join([f"UPPER({col}) LIKE UPPER(:search_term)" for col in text_columns])
    sql = f"SELECT * FROM {table} WHERE {like_clauses}"
```

### 8.2. ORDER BY
-----------------------------------------
CO TO JEST: Sortowanie wynikow

GDZIE POKAZAC:
- Aplikacja: Panel Admin -> dowolna tabela -> kliknij naglowek kolumny
- Strzalka w gore/dol pokazuje kierunek sortowania

### 8.3. GROUP BY z funkcjami agregujacymi
-----------------------------------------
CO TO JEST: Grupowanie danych z obliczeniami

GDZIE POKAZAC:
- Aplikacja: Panel Admin -> Podsumowania -> "Zuzycie mediow"
- Lub: Narzedzia administratora -> Raporty (zakladka)

KOD SQL (widok v_oplaty_summary):
```sql
SELECT 
    m.numer_mieszkania,
    COUNT(*) as liczba_oplat,
    SUM(o.kwota) as suma_oplat,
    SUM(CASE WHEN o.status_oplaty = 'nieoplacone' THEN o.kwota ELSE 0 END) as zaleglosci
FROM mieszkanie m
LEFT JOIN oplata o ON m.id_mieszkania = o.id_mieszkania
GROUP BY m.id_mieszkania, m.numer_mieszkania
```

### 8.4. Funkcje agregujace: SUM, COUNT, AVG, MAX, MIN
-----------------------------------------
CO TO JEST: Funkcje obliczeniowe na zbiorach danych

GDZIE POKAZAC:
- Aplikacja: Panel Admin -> Pulpit glowny (karty ze statystykami)
- "Suma oplat", "Liczba budynkow", itp.

KOD SQL:
```sql
SELECT COUNT(*) FROM budynek;
SELECT SUM(kwota) FROM oplata;
SELECT AVG(powierzchnia) FROM mieszkanie;
```

### 8.5. CASE WHEN
-----------------------------------------
CO TO JEST: Wyrazenia warunkowe w SQL

GDZIE POKAZAC:
- Aplikacja: Panel Admin -> Podsumowania -> "Status napraw"
- Widac przetlumaczone statusy ("Oczekuje na realizacje" zamiast "zgloszona")

KOD SQL (widok v_naprawy_status):
```sql
SELECT 
    CASE status
        WHEN 'zgloszona' THEN 'Oczekuje na realizacje'
        WHEN 'w_realizacji' THEN 'W trakcie naprawy'
        WHEN 'zakonczona' THEN 'Naprawiono'
        ELSE status
    END as status_opis
FROM naprawa
```

================================================================================
## LAB 9: VIEW, MATERIALIZED VIEW, INVISIBLE columns
================================================================================

### 9.1. VIEW prosty
-----------------------------------------
CO TO JEST: Widok laczacy dane z wielu tabel

GDZIE POKAZAC:
- Aplikacja: Panel Admin -> Podsumowania -> "Mieszkania z adresami"

KOD SQL (INIT_DB.sql):
```sql
CREATE OR REPLACE VIEW v_mieszkania_info AS
SELECT m.id_mieszkania, m.numer_mieszkania, m.powierzchnia,
       b.adres, b.liczba_pieter
FROM mieszkanie m
JOIN budynek b ON m.id_budynku = b.id_budynku;
```

### 9.2. VIEW zlozony z agregacja
-----------------------------------------
CO TO JEST: Widok z funkcjami agregujacymi

GDZIE POKAZAC:
- Aplikacja: Panel Admin -> Podsumowania -> "Podsumowanie oplat"

KOD SQL:
```sql
CREATE OR REPLACE VIEW v_oplaty_summary AS
SELECT m.numer_mieszkania,
       COUNT(*) as liczba_oplat,
       SUM(o.kwota) as suma_oplat
FROM mieszkanie m
LEFT JOIN oplata o ON m.id_mieszkania = o.id_mieszkania
GROUP BY m.id_mieszkania, m.numer_mieszkania;
```

### 9.3. MATERIALIZED VIEW
-----------------------------------------
CO TO JEST: Widok zmaterializowany (keszowany)

GDZIE POKAZAC:
- Aplikacja: Panel Admin -> Narzedzia administratora -> Raporty -> "Statystyki keszowane"
- Lub: Pulpit glowny (karty ze statystykami)

KOD SQL (INIT_DB.sql):
```sql
CREATE MATERIALIZED VIEW mv_dashboard_stats
BUILD IMMEDIATE
REFRESH FORCE ON DEMAND
AS
SELECT 
    (SELECT COUNT(*) FROM budynek) as liczba_budynkow,
    (SELECT COUNT(*) FROM mieszkanie) as liczba_mieszkan,
    (SELECT COUNT(*) FROM czlonek) as liczba_czlonkow,
    (SELECT NVL(SUM(kwota), 0) FROM oplata) as suma_oplat
FROM dual;
```

### 9.4. INVISIBLE columns
-----------------------------------------
CO TO JEST: Kolumny niewidoczne przy SELECT *

GDZIE POKAZAC:
- Aplikacja: Panel Admin -> Narzedzia administratora -> Raporty -> "Bezpieczne dane czlonkow"
- Widac ze NIE MA kolumn PESEL i telefon!

KOD SQL:
```sql
CREATE OR REPLACE VIEW v_czlonek_bezpieczny AS
SELECT 
    id_czlonka,
    imie,
    nazwisko,
    email,
    data_przystapienia,
    pesel INVISIBLE,      -- ta kolumna jest ukryta!
    telefon INVISIBLE     -- ta kolumna tez!
FROM czlonek;
```

WYTLUMACZENIE: Gdy zrobisz SELECT * FROM v_czlonek_bezpieczny, kolumny PESEL i telefon NIE zostana zwrocone. Trzeba je jawnie podac: SELECT pesel FROM v_czlonek_bezpieczny.

================================================================================
## LAB 10: Rozne typy JOIN
================================================================================

### 10.1. INNER JOIN
-----------------------------------------
CO TO JEST: Laczy tylko pasujace rekordy z obu tabel

GDZIE POKAZAC:
- Aplikacja: Panel Admin -> Podsumowania -> "Mieszkania z adresami"

KOD SQL:
```sql
SELECT * FROM mieszkanie m
INNER JOIN budynek b ON m.id_budynku = b.id_budynku;
```

### 10.2. LEFT JOIN
-----------------------------------------
CO TO JEST: Wszystkie rekordy z lewej tabeli + pasujace z prawej

GDZIE POKAZAC:
- Widok v_oplaty_summary (wszystkie mieszkania, nawet bez oplat)

### 10.3. RIGHT JOIN
-----------------------------------------
CO TO JEST: Wszystkie rekordy z prawej tabeli + pasujace z lewej

GDZIE POKAZAC:
- Aplikacja: Panel Admin -> Narzedzia administratora -> Raporty -> "Obciazenie pracownikow"

KOD SQL:
```sql
CREATE OR REPLACE VIEW v_pracownicy_naprawy AS
SELECT p.imie, p.nazwisko, n.opis_usterki
FROM naprawa n
RIGHT JOIN pracownik p ON n.id_pracownika = p.id_pracownika;
-- Pokaze WSZYSTKICH pracownikow, nawet tych bez napraw
```

### 10.4. FULL OUTER JOIN
-----------------------------------------
CO TO JEST: Wszystkie rekordy z obu tabel

GDZIE POKAZAC:
- Aplikacja: Panel Admin -> Narzedzia administratora -> Raporty -> "Zestawienie oplat"

KOD SQL:
```sql
CREATE OR REPLACE VIEW v_oplaty_uslugi_full AS
SELECT o.id_oplaty, u.nazwa_uslugi
FROM oplata o
FULL OUTER JOIN uslugi u ON o.id_uslugi = u.id_uslugi;
```

### 10.5. CROSS JOIN
-----------------------------------------
CO TO JEST: Iloczyn kartezjanski (wszystkie kombinacje)

GDZIE POKAZAC:
- Aplikacja: Panel Admin -> Narzedzia administratora -> Raporty -> "Matryca budynki-uslugi"

KOD SQL:
```sql
CREATE OR REPLACE VIEW v_budynki_uslugi_cross AS
SELECT b.adres, u.nazwa_uslugi
FROM budynek b
CROSS JOIN uslugi u;
-- Kazdy budynek x kazda usluga
```

### 10.6. SELF JOIN
-----------------------------------------
CO TO JEST: Tabela laczy sie sama ze soba

GDZIE POKAZAC:
- Aplikacja: Panel Admin -> Narzedzia administratora -> Raporty -> "Zespoly stanowiskowe"

KOD SQL:
```sql
CREATE OR REPLACE VIEW v_pracownicy_koledzy AS
SELECT p1.imie || ' ' || p1.nazwisko as pracownik1,
       p2.imie || ' ' || p2.nazwisko as pracownik2,
       p1.stanowisko
FROM pracownik p1
JOIN pracownik p2 ON p1.stanowisko = p2.stanowisko AND p1.id_pracownika < p2.id_pracownika;
-- Pary pracownikow na tym samym stanowisku
```

### 10.7. JOIN 3 tabel (MULTI-TABLE JOIN)
-----------------------------------------
CO TO JEST: Laczenie wiecej niz 2 tabel

GDZIE POKAZAC:
- Aplikacja: Panel Admin -> Narzedzia administratora -> Raporty -> "Pelne dane mieszkancow"

KOD SQL:
```sql
CREATE OR REPLACE VIEW v_czlonkowie_pelne_info AS
SELECT c.imie, c.nazwisko, m.numer_mieszkania, b.adres
FROM czlonek c
JOIN mieszkanie m ON c.id_mieszkania = m.id_mieszkania
JOIN budynek b ON m.id_budynku = b.id_budynku;
-- Laczy 3 tabele: czlonek -> mieszkanie -> budynek
```

================================================================================
## LAB 11: PROCEDURE, FUNCTION, SEQUENCE, CURSOR
================================================================================

### 11.1. SEQUENCE
-----------------------------------------
CO TO JEST: Generator unikalnych numerow

GDZIE POKAZAC:
- Plik: INIT_DB.sql (szukaj "CREATE SEQUENCE")

KOD SQL:
```sql
CREATE SEQUENCE spotkanie_seq START WITH 1000 INCREMENT BY 1;
CREATE SEQUENCE naprawa_seq START WITH 1000 INCREMENT BY 1;
```

UZYCIE:
```sql
INSERT INTO naprawa (id_naprawy, ...) VALUES (naprawa_seq.NEXTVAL, ...);
```

### 11.2. PROCEDURE z parametrami IN/OUT
-----------------------------------------
CO TO JEST: Procedura z parametrami wejsciowymi i wyjsciowymi

GDZIE POKAZAC:
- Aplikacja: Panel Admin -> Narzedzia administratora -> "Zwieksz ceny uslug"
- Wpisz procent (np. 10) i kliknij przycisk

KOD SQL:
```sql
CREATE OR REPLACE PROCEDURE zwieksz_oplaty(
    p_procent IN NUMBER DEFAULT 10,
    p_liczba_zmienionych OUT NUMBER
) AS
BEGIN
    UPDATE uslugi SET cena_jednostkowa = cena_jednostkowa * (1 + p_procent/100);
    p_liczba_zmienionych := SQL%ROWCOUNT;
    COMMIT;
END;
```

### 11.3. PROCEDURE z obsluga wyjatkow
-----------------------------------------
CO TO JEST: Procedura z blokiem EXCEPTION

GDZIE POKAZAC:
- Plik: INIT_DB.sql (procedura dodaj_czlonka)

KOD SQL:
```sql
CREATE OR REPLACE PROCEDURE dodaj_czlonka(
    p_imie IN VARCHAR2,
    p_nazwisko IN VARCHAR2,
    p_id OUT NUMBER
) AS
BEGIN
    INSERT INTO czlonek (imie, nazwisko) VALUES (p_imie, p_nazwisko)
    RETURNING id_czlonka INTO p_id;
    COMMIT;
EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        RAISE_APPLICATION_ERROR(-20001, 'Czlonek juz istnieje');
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE;
END;
```

### 11.4. FUNCTION
-----------------------------------------
CO TO JEST: Funkcja zwracajaca wartosc

GDZIE POKAZAC:
- Aplikacja: Panel Admin -> Narzedzia administratora -> "Dodaj oplate"
- Wybierz mieszkanie i usluge, wpisz zuzycie -> kwota oblicza sie automatycznie!

KOD SQL:
```sql
CREATE OR REPLACE FUNCTION dodaj_oplate_fn(
    p_id_mieszkania IN NUMBER,
    p_id_uslugi IN NUMBER,
    p_zuzycie IN NUMBER
) RETURN NUMBER AS
    v_cena NUMBER;
    v_kwota NUMBER;
    v_id_oplaty NUMBER;
BEGIN
    SELECT cena_jednostkowa INTO v_cena FROM uslugi WHERE id_uslugi = p_id_uslugi;
    v_kwota := v_cena * p_zuzycie;
    INSERT INTO oplata (id_mieszkania, id_uslugi, kwota, zuzycie, status_oplaty)
    VALUES (p_id_mieszkania, p_id_uslugi, v_kwota, p_zuzycie, 'nieoplacone')
    RETURNING id_oplaty INTO v_id_oplaty;
    COMMIT;
    RETURN v_id_oplaty;
END;
```

### 11.5. FUNCTION z CURSOR
-----------------------------------------
CO TO JEST: Funkcja iterujaca po rekordach za pomoca kursora

GDZIE POKAZAC:
- Plik: INIT_DB.sql (funkcja pobierz_czlonkow_budynku)

KOD SQL:
```sql
CREATE OR REPLACE FUNCTION pobierz_czlonkow_budynku(p_id_budynku IN NUMBER) 
RETURN VARCHAR2 AS
    v_wynik VARCHAR2(4000) := '';
    CURSOR c_czlonkowie IS
        SELECT c.imie, c.nazwisko
        FROM czlonek c
        JOIN mieszkanie m ON c.id_mieszkania = m.id_mieszkania
        WHERE m.id_budynku = p_id_budynku;
BEGIN
    FOR rec IN c_czlonkowie LOOP
        v_wynik := v_wynik || rec.imie || ' ' || rec.nazwisko || ', ';
    END LOOP;
    RETURN RTRIM(v_wynik, ', ');
END;
```

================================================================================
## LAB 12: PACKAGE
================================================================================

### 12.1. PACKAGE SPECIFICATION + BODY
-----------------------------------------
CO TO JEST: Pakiet grupujacy procedury i funkcje

GDZIE POKAZAC:
- Plik: INIT_DB.sql (szukaj "CREATE OR REPLACE PACKAGE")

KOD SQL - SPECYFIKACJA:
```sql
CREATE OR REPLACE PACKAGE coop_pkg AS
    PROCEDURE zwieksz_oplaty_pkg(p_procent IN NUMBER DEFAULT 10);
    FUNCTION policz_naprawy_pracownika(p_id_pracownika IN NUMBER) RETURN NUMBER;
    FUNCTION suma_oplat_mieszkania(p_id_mieszkania IN NUMBER) RETURN NUMBER;
END coop_pkg;
```

KOD SQL - IMPLEMENTACJA:
```sql
CREATE OR REPLACE PACKAGE BODY coop_pkg AS
    PROCEDURE zwieksz_oplaty_pkg(p_procent IN NUMBER DEFAULT 10) AS
    BEGIN
        UPDATE uslugi SET cena_jednostkowa = cena_jednostkowa * (1 + p_procent/100);
        COMMIT;
    END;
    
    FUNCTION policz_naprawy_pracownika(p_id_pracownika IN NUMBER) RETURN NUMBER AS
        v_liczba NUMBER;
    BEGIN
        SELECT COUNT(*) INTO v_liczba FROM naprawa WHERE id_pracownika = p_id_pracownika;
        RETURN v_liczba;
    END;
    
    FUNCTION suma_oplat_mieszkania(p_id_mieszkania IN NUMBER) RETURN NUMBER AS
        v_suma NUMBER;
    BEGIN
        SELECT NVL(SUM(kwota), 0) INTO v_suma FROM oplata WHERE id_mieszkania = p_id_mieszkania;
        RETURN v_suma;
    END;
END coop_pkg;
```

### 12.2. PACKAGE z obsluga wyjatkow
-----------------------------------------
GDZIE POKAZAC:
- Plik: INIT_DB.sql (pakiet coop_crud_pkg)

KOD SQL:
```sql
CREATE OR REPLACE PACKAGE coop_crud_pkg AS
    PROCEDURE insert_budynek(p_adres VARCHAR2, p_liczba_pieter NUMBER, p_id OUT NUMBER);
    FUNCTION pobierz_nazwisko_czlonka(p_id_czlonka NUMBER) RETURN VARCHAR2;
END coop_crud_pkg;

CREATE OR REPLACE PACKAGE BODY coop_crud_pkg AS
    FUNCTION pobierz_nazwisko_czlonka(p_id_czlonka NUMBER) RETURN VARCHAR2 AS
        v_nazwisko VARCHAR2(100);
    BEGIN
        SELECT nazwisko INTO v_nazwisko FROM czlonek WHERE id_czlonka = p_id_czlonka;
        RETURN v_nazwisko;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RETURN 'Nie znaleziono';
        WHEN TOO_MANY_ROWS THEN
            RETURN 'Wiele wynikow';
    END;
END coop_crud_pkg;
```

================================================================================
## LAB 13: TRIGGER, EXECUTE IMMEDIATE
================================================================================

### 13.1. TRIGGER AFTER INSERT/UPDATE/DELETE (audyt)
-----------------------------------------
CO TO JEST: Trigger automatycznie logujacy zmiany

GDZIE POKAZAC:
- Aplikacja: Panel Admin -> Narzedzia administratora -> "Historia zmian"
- Zrob jakas zmiane w tabeli Czlonkowie i wrocac tu zobaczyc log!

KOD SQL:
```sql
CREATE OR REPLACE TRIGGER trg_audit_czlonek
AFTER INSERT OR UPDATE OR DELETE ON czlonek
FOR EACH ROW
BEGIN
    IF INSERTING THEN
        INSERT INTO log_zmian_czlonka (typ_operacji, id_czlonka, nowe_dane, data_zmiany)
        VALUES ('INSERT', :NEW.id_czlonka, :NEW.imie || ' ' || :NEW.nazwisko, SYSDATE);
    ELSIF UPDATING THEN
        INSERT INTO log_zmian_czlonka (typ_operacji, id_czlonka, stare_dane, nowe_dane, data_zmiany)
        VALUES ('UPDATE', :NEW.id_czlonka, :OLD.imie || ' ' || :OLD.nazwisko, 
                :NEW.imie || ' ' || :NEW.nazwisko, SYSDATE);
    ELSIF DELETING THEN
        INSERT INTO log_zmian_czlonka (typ_operacji, id_czlonka, stare_dane, data_zmiany)
        VALUES ('DELETE', :OLD.id_czlonka, :OLD.imie || ' ' || :OLD.nazwisko, SYSDATE);
    END IF;
END;
```

### 13.2. TRIGGER BEFORE z walidacja
-----------------------------------------
CO TO JEST: Trigger blokujacy nieprawidlowe dane

GDZIE POKAZAC:
- Aplikacja: Panel Admin -> Oplaty -> Dodaj rekord
- Sprobuj wpisac ujemna kwote -> dostaniesz BLAD!

KOD SQL:
```sql
CREATE OR REPLACE TRIGGER trg_walidacja_oplaty
BEFORE INSERT OR UPDATE OF kwota ON oplata
FOR EACH ROW
BEGIN
    IF :NEW.kwota < 0 THEN
        RAISE_APPLICATION_ERROR(-20002, 'Kwota oplaty nie moze byc ujemna');
    END IF;
END;
```

### 13.3. EXECUTE IMMEDIATE (dynamiczny SQL)
-----------------------------------------
CO TO JEST: Wykonywanie dynamicznie budowanego SQL

GDZIE POKAZAC:
- Aplikacja: Panel Admin -> Narzedzia administratora -> "Statystyki tabel"
- Wyswietla liczbe rekordow w KAZDEJ tabeli (dynamicznie!)

KOD SQL:
```sql
CREATE OR REPLACE FUNCTION policz_rekordy(p_nazwa_tabeli IN VARCHAR2) 
RETURN NUMBER AS
    v_sql VARCHAR2(200);
    v_liczba NUMBER;
BEGIN
    v_sql := 'SELECT COUNT(*) FROM ' || p_nazwa_tabeli;
    EXECUTE IMMEDIATE v_sql INTO v_liczba;
    RETURN v_liczba;
END;
```

UZYCIE W BACKENDZIE (main.py):
```python
@app.get("/procedures/count-records/{table}")
async def count_records(table: str):
    cursor.execute("SELECT policz_rekordy(:table_name) FROM dual", {"table_name": table})
```

================================================================================
## SZYBKA SCIAGA - GDZIE CO ZNAJDE W APLIKACJI
================================================================================

PULPIT GLOWNY:
- COUNT, SUM (liczba budynkow, suma oplat)
- MATERIALIZED VIEW (mv_dashboard_stats)

TABELE (Budynki, Mieszkania, itd.):
- CREATE TABLE, PRIMARY KEY, FOREIGN KEY
- INSERT, UPDATE, DELETE
- WHERE LIKE (pole szukaj)
- ORDER BY (klikniecie naglowka)

PODSUMOWANIA:
- VIEW proste i zlozone
- GROUP BY, funkcje agregujace
- CASE WHEN

NARZEDZIA ADMINISTRATORA:
- PROCEDURE (zwieksz_oplaty)
- FUNCTION (dodaj_oplate_fn, policz_rekordy)
- TRIGGER (Historia zmian = trg_audit_czlonek)
- EXECUTE IMMEDIATE (Statystyki tabel)
- Rozne typy JOIN (RIGHT, FULL, CROSS, SELF)
- MATERIALIZED VIEW
- INVISIBLE columns

PORTAL MIESZKANCA:
- VIEW (v_moje_oplaty)
- PROCEDURE (zglos_naprawe)
- JOIN 3 tabel (logowanie)

================================================================================
## PYTANIA JAKIE MOZE ZADAC WYKLADOWCA
================================================================================

P: Gdzie masz PRIMARY KEY?
O: Kazda tabela ma kolumne id_* z PRIMARY KEY. Np. budynek.id_budynku

P: Gdzie masz FOREIGN KEY z ON DELETE CASCADE?
O: INIT_DB.sql, tabela mieszkanie - gdy usuniesz budynek, mieszkania tez sie usuna

P: Pokaz WHERE LIKE
O: Panel Admin -> dowolna tabela -> wpisz cos w "Szukaj..."

P: Pokaz GROUP BY z SUM
O: Podsumowania -> "Podsumowanie oplat per mieszkanie"

P: Pokaz MATERIALIZED VIEW
O: Narzedzia administratora -> Raporty -> "Statystyki keszowane"

P: Pokaz INVISIBLE columns
O: Narzedzia administratora -> Raporty -> "Bezpieczne dane czlonkow" - nie ma PESEL!

P: Pokaz rozne typy JOIN
O: Narzedzia administratora -> Raporty -> jest RIGHT, FULL, CROSS, SELF JOIN

P: Pokaz procedure
O: Narzedzia administratora -> "Zwieksz ceny uslug"

P: Pokaz funkcje
O: Narzedzia administratora -> "Dodaj oplate" (automatycznie liczy kwote)

P: Pokaz trigger
O: Narzedzia administratora -> "Historia zmian" + zrob jakas zmiane w Czlonkach

P: Pokaz EXECUTE IMMEDIATE
O: Narzedzia administratora -> "Statystyki tabel"

P: Pokaz SEQUENCE
O: INIT_DB.sql - spotkanie_seq, naprawa_seq

P: Pokaz PACKAGE
O: INIT_DB.sql - coop_pkg, coop_crud_pkg

================================================================================
KONIEC PRZEWODNIKA
================================================================================
